from __future__ import absolute_import, division, print_function

import os
import sys
import argparse
import time

import pytorch_lightning as pl
from pytorch_lightning import Trainer
from pytorch_lightning.loggers import TensorBoardLogger
from pytorch_lightning.callbacks import Callback
from pytorch_lightning.core.saving import save_hparams_to_yaml


# Append project dir to sys path so other modules are available
current_dir = os.getcwd()  # ~/endoscopic-image-analysis/src/data
project_root = os.path.dirname(current_dir)  # ~/endoscopic-image-analysis
sys.path.append(project_root)

from src.utils import utils
from src.dataset_preproc.pl_datamodules import EndoDataModule
from src.pl_modules.unet import Unet
from pytorch_lightning.utilities.seed import reset_seed, seed_everything

utils.set_cwd()
project_root = os.getcwd()

seed = 10
seed_everything(seed, workers=True)


class SaveHyperParams(Callback):
    """ Save the gen_config, trainer_config and other configs to the hparams yaml file
    that is generated by the lightning experiment
    """
    def __init__(self, checkpoint_dict = None):
        super(SaveHyperParams, self).__init__()
        self.checkpoint_dict = checkpoint_dict

    def on_save_checkpoint(self, trainer: "pl.Trainer", pl_module: "pl.LightningModule", checkpoint: dict) -> None:
        if trainer.current_epoch == 0:
            file_path = f"{trainer.logger.log_dir}/hparams.yaml"
            save_hparams_to_yaml(config_yaml=file_path, hparams=self.checkpoint_dict)


def get_namespace(group, args):
    return argparse.Namespace(**dict((k, v) for k, v in vars(args).items() if k in group))


def main(args, config_dict):
    [gen_namespace, model_namespace, data_namespace, trainer_namespace] = \
        [get_namespace(group, args) for group in [config_dict['gen_arg_names'], config_dict['model_arg_names'],
                                                  config_dict['data_arg_names'], config_dict['trainer_arg_names']]]

    data_config = utils.json_loader(data_namespace.data_config_path) if data_namespace.data_config_path else \
        {k: v for k, v in vars(data_namespace).items()}

    model_config = utils.json_loader(model_namespace.model_config_path) if model_namespace.model_config_path else \
        {k: v for k, v in vars(model_namespace).items()}

    gen_config = utils.json_loader(gen_namespace.config_path) if gen_namespace.config_path else \
        {k: v for k, v in vars(gen_namespace).items()}

    trainer_config = {k: v for k, v in vars(trainer_namespace).items()}

    hparam_dict = {"gen_config": gen_config,
                   "model_config": model_config,
                   "data_config": data_config,
                   "trainer_config": trainer_config}

    # version_name = str(utils.get_time_stamp())
    exp_name = gen_namespace.exp_name if gen_namespace.exp_name else "trial_run"
    suffix = "" if gen_namespace.save else "_"+str(utils.get_time_stamp())

    tb_logger = TensorBoardLogger(save_dir=gen_namespace.log_dir,
                                  name=gen_namespace.model_name,
                                  version=exp_name+suffix,
                                  default_hp_metric=False)

    # Take care of device selection, on local/cluster
    gpus = [trainer_namespace.gpus] if gen_namespace.manual_select_gpu else trainer_namespace.gpus

    # ********************* Firing up the whole lightning system here *************************************
    # Trainer config is a dict, namespace is an accessible config
    endo_data_module = EndoDataModule(**data_config)
    model = Unet(**model_config, lr=gen_namespace.lr)
    model.init_weights()

    trainer = Trainer.from_argparse_args(args,
                                         logger=tb_logger,
                                         callbacks=[SaveHyperParams(hparam_dict)],
                                         gpus=gpus)
    trainer.fit(model, endo_data_module)
    reset_seed()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Parameters")
    parser.add_argument("--config_path", type=str, default="",
                        help="path to general script config file")

    parser.add_argument("--model_name", type=str, default="suture_detection",
                        help="the name of the folder to save the model in")

    parser.add_argument("--exp_name", type=str, default="",
                        help="Name of the experiment under the model")

    parser.add_argument("--log_dir", type=str, default=os.path.join(project_root, "../experiments"),
                        help="log directory")

    parser.add_argument("--save", action="store_true",
                        help="if set, saves model for cross validation within exp folder")

    parser.add_argument('--lr', type=float, default=0.001,
                        help='initial learning rate')

    parser.add_argument('--manual_select_gpu',
                        help="if set, then 'gpus' argument specified which device(s) to train on",
                        action="store_true")
    gen_arg_names = set(vars(parser.parse_known_args()[0]).keys())

    parser = Unet.add_model_specific_args(parser)
    model_arg_names = set(vars(parser.parse_known_args()[0]).keys()) - gen_arg_names

    parser = EndoDataModule.add_data_specific_args(parser)
    data_arg_names = set(vars(parser.parse_known_args()[0]).keys()) - gen_arg_names - model_arg_names

    parser = Trainer.add_argparse_args(parser)
    trainer_arg_names = set(vars(parser.parse_known_args()[0]).keys())-gen_arg_names-model_arg_names-data_arg_names
    parsed_args = parser.parse_args()

    before_train_time = time.time()
    main(args=parsed_args, config_dict={'gen_arg_names': gen_arg_names,
                                        'model_arg_names': model_arg_names,
                                        'data_arg_names': data_arg_names,
                                        'trainer_arg_names': trainer_arg_names})
    train_duration = time.time() - before_train_time

    hrs, minutes, sec = utils.get_hrs_min_sec(train_duration)
    print('Total train duration: {} hrs {} min {} sec'.format(hrs, minutes, sec))
